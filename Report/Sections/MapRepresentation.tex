\section{Map Representation}
\label{MapRepresentation}

A map in Starcraft 2 is represented as a map of tiles, where a tile can have have a a height (impassable for ground troops, and 3 heights that ground troops can traverse), cliffs between heightlevels, ramps that connect heightlevels, buildings, resources and Xel'Naga towers (provides vision while a unit is nearby). The map can, of course, also contain units but they are irrelevant for our purposes. The only units a basic map contains are the initial 5 (\textbf{6?}) workers that always start next to one's starting base, so we can ignore units in our generation.

We did not have direct access to the map representation used in Starcraft, so we had to create our own map representation. As we wanted to use evolutionary algorithms (a subtype of genetic algorithms), we decided to split our representation into two parts: A genotype and a phenotype.

\subsection{Genotype}
\label{MapRepresentation_Genotype}

The genotype contains a list of the items the map should contain and their position on the map. The position uses a a radial system, where the midpoint is the middle of the map. Each item has an angle and a distance. The angle determines the angle from the middle of the map (with 0$^o$ being right and going counterclockwise (\textbf{Check if correct})). The distance is represented as a percentage of the distance from the middle of the map in a straight line to where the angle will hit the edge of the map.

There were other genotype representations we considered, but decided against for various reasons:

\begin{itemize}

	\item \textbf{Direct representation} - A direct grid representation would be very easy to convert to a phenotype, but it is very close to being a phenotype already which defeats the purpose of having a genotype. It is also more time-consuming to mutate compared to the radial one, as we would have to create a copy of the entire grid every time we mutate.

	\item \textbf{Coordinate representation} - Why did we not choose this one? (I honestly cannot remember)

	\item \textbf{Seed representation} - A seed representation would have been the most simplistic type of representation we could have used, but would also have been the most difficult to code for. What part of the seed controls what, how do we interpret it, how do we mutate it and how do we ensure it does not end up producing completely impossible feature placements?

\end{itemize}

\subsection{Map Data Structure}
\label{MapRepresentation_MapStructure}

In order to work with maps, we needed a structure that represents the entire map, not just the features in it.

As mentioned above, a map is made up of height-levels and various features the players can use to their advantage. In a map it is possible for a tile to contain a height-level (it always will), a location for a base and destructible rocks that have to be cleared before a base can be built. This situation is the one that had the most impact on the design of our map data structure.

We use three 2-sided arrays to represent the map. One array represents the heightmap itself, height-levels, ramps and cliffs. The second represents features in the map, bases, resources, and Xel'Naga towers. The third represents the placement of destructible rocks.

\textit{The initial heightmap} is generated by a cellular automata (see section \ref{CA_Our} on page \pageref{CA_Our}). The map structure is then in charge of smoothing out any irregularities in the heightmap, placing cliffs and smoothing out cliffs. The map structure also has the ability to print the map it represents to a .png file for an easy visual representation.

\textit{Heightmap smoothing} is done through the use of a cellular automata, using a set of rules created specifically for smoothing out the heightmap. The rules check if a tile fits in with the surrounding tiles and if it does not, it will be changed to the height that occours the most in the surrounding neighbourhood.

\textit{Cliff placement} is done after the heightmap has been smoothed. The map structure iterate over all tiles on the map and check their neighbouring tiles (using the Von Neumann neighbourhood). If any of the neighbouring tiles are of a lower heightlevel than the current tile, the neighbour tile is transformed into a cliff, unless something will prevent that (gas, minerals, a base, etc). In that case, the tile we are at will become a cliff instead.

\textit{Cliff smoothing} was implemented in order to avoid situations where remnants of cliffs would be spread around the map, without bordering up to two different height levels (which is where cliffs should be). Such excess cliffs are removed by iterating over all tiles in the heightmap and, if a tile is a cliff, looking at its neighbours (using the Moore neighbourhood). If there is only one other height-level in its neighbourhood, the cliff is changed to that height-level instead.

After these processes have been run, the map is ready to receive data from the representation structure and be turned into a complete map.

The visual representation is created in two steps: First we draw the heightmap as a bitmap, where each heightlevel has a different tile icon. After that, every item - including destructible rocks - is drawn on top of the already-existing bitmap, in order to avoid items being overwritten by heightlevels. When the items have been drawn, the map is saved as a .png file.

\textbf{Picture of generated map}